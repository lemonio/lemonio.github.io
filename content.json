{"meta":{"title":"Lemon","subtitle":"不忘初心 方得始终","description":null,"author":"Lemon","url":"http://yoursite.com","root":"/"},"pages":[{"title":"作者简介","date":"2019-04-07T15:20:30.000Z","updated":"2019-09-17T10:05:35.698Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-17T10:05:35.697Z","updated":"2019-09-17T10:05:35.697Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-17T10:05:35.697Z","updated":"2019-09-17T10:05:35.697Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-09-17T10:05:35.699Z","updated":"2019-09-17T10:05:35.699Z","comments":true,"path":"2019/09/17/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"AM335x PROCESSOR-SDK-LINUX-AM335X  04_03_00_05移植记录","slug":"AM335x PROCESSOR-SDK-LINUX-AM335X  04_03_00_05移植记录","date":"2018-11-11T17:14:30.000Z","updated":"2019-09-17T10:05:35.699Z","comments":true,"path":"2018/11/12/AM335x PROCESSOR-SDK-LINUX-AM335X  04_03_00_05移植记录/","link":"","permalink":"http://yoursite.com/2018/11/12/AM335x PROCESSOR-SDK-LINUX-AM335X  04_03_00_05移植记录/","excerpt":"","text":"文中使用TI SDK 版本为PROCESSOR-SDK-LINUX-AM335X 04_03_00_05，SDK下载地址： ti-processor-sdk-linux-am335x-evm-04.03.00.05-Linux-x86-Install.bin AM335x启动过程工程目录编译指令u-bootmake CROSS_COMPILE=arm-linux-gnueabihf- O=am335x_evm am335x_evm_defconfigmake CROSS_COMPILE=arm-linux-gnueabihf- O=am335x_evm menuconfigmake CROSS_COMPILE=arm-linux-gnueabihf- O=am335x_evmmake CROSS_COMPILE=arm-linux-gnueabihf- distclean kernelmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- tisdk_am335x-evm_defconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distcleanmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImagemake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- am335x-evm.dtbmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modulesmake ARCH=arm INSTALL_MOD_PATH=/media/huiwei/rootfs modules_install rootfsmkfs.ubifs -F -q -r filesystem -m 2048 -e 126976 -c 2047 -o ubifs.imgubinize -o ubi.img -m 2048 -p 128KiB ubinize.cfg U-Boot移植EEPROM处理TI的am335x evm开发板使用了一个eeprom保存了板载配置信息，用来区分不同板卡的型号。如果板卡没有这个eeprom，需要修改U-Boot中eeprom的读取部分。否则会导致MLO无法启动，串口无任何信息输出。 123456789// 修改do_board_detect(board/ti/am335x/board.c)// 关于板卡的检测是由CONFIG_TI_I2C_BOARD_DETECT宏来控制，位于board/ti/common/Kconfig。#ifdef CONFIG_TI_I2C_BOARD_DETECTvoid do_board_detect(void)&#123; ti_i2c_eeprom_am_get_default(-1, CONFIG_SYS_I2C_EEPROM_ADDR);&#125;#endif 1234567891011121314151617181920212223// 添加声明ti_i2c_eeprom_am_get_default(board/ti/common/board_detect.h)int ti_i2c_eeprom_am_get_default(int bus_addr, int dev_addr);// 添加实现ti_i2c_eeprom_am_get_default(board/ti/common/board_detect.c)int __maybe_unused ti_i2c_eeprom_am_get_default(int bus_addr, int dev_addr)&#123; struct ti_common_eeprom *ep; ep = TI_EEPROM_DATA; ep-&gt;header = 0xEE3355AA; strcpy(ep-&gt;name, \"A335X_SK\"); strcpy(ep-&gt;version, \"1.2B\"); strcpy(ep-&gt;serial, \"45124P196447\"); strcpy(ep-&gt;config, \"SKU#00\"); ep-&gt;mac_addr[0][0]=0x11; ep-&gt;mac_addr[0][1]=0x22; ep-&gt;mac_addr[0][2]=0x33; ep-&gt;mac_addr[0][3]=0x44; ep-&gt;mac_addr[0][4]=0x55; ep-&gt;mac_addr[0][5]=0x66; return 0;&#125; NAND配置修改完eeprom之后，将MLO和uboot.img放入SD卡boot分区，设置SD卡启动模式，这时串口有了打印信息。 12345678910111213141516171819U-Boot SPL 2017.01-00458-ga0c95a6-dirty (Dec 28 2018 - 23:46:03)Trying to boot from MMC1reading uboot.envreading u-boot.imgreading u-boot.imgreading u-boot.imgreading u-boot.imgU-Boot 2017.01-00458-ga0c95a6-dirty (Dec 28 2018 - 23:46:03 -0800)CPU : AM335X-GP rev 2.1Model: TI AM335x EVM-SKDRAM: 256 MiBNAND: 0 MiBMMC: OAMP SD/MMC: 0, OMAP SD/MMC: 1reading uboot.envNet: Could not get PHY for cpsw: addr 0cpsw, usb_etherHit any key to stop autoboot: 0 从打印日志NAND: 0 MiB来看，uboot没有检测到Nand Flash。 当前的uboot版本已经引入了驱动模型DM（driver model），DM为驱动的定义和访问接口提供了统一的方法，它依赖于uboot中的dts。关于NAND的DM配置选项为CONFIG_DM_NAND。查看am335x_evm/.config文件发现CONFIG_DM_NAND=y(该配置在configs/am335x_evm_defconfig中被设置)。我们可以把配置关掉或者修改uboot中的dts文件。 NAND的DM驱动在drivers/mtd/nand/omap_gpmc.c中 12345678910111213141516//drivers/mtd/nand/omap_gpmc.cstatic const struct udevice_id omap_gpmc_ids[] = &#123; &#123; .compatible = \"ti,am3352-gpmc\" &#125;, &#123; &#125;&#125;;U_BOOT_DRIVER(omap_gpmc) = &#123; .name = \"omap_gpmc\", .id = UCLASS_NAND, .of_match = omap_gpmc_ids, .ofdata_to_platdata = omap_gpmc_ofdata_to_platdata, .probe = omap_gpmc_probe, .priv_auto_alloc_size = sizeof(struct nand_chip), .platdata_auto_alloc_size = sizeof(struct omap_gpmc_platdata), .flags = DM_FLAG_ALLOC_PRIV_DMA,&#125;; 由于前面指定了板卡的类型A335X_SK，其对应的dts文件为am335x-evmsk.dts 在am335x-evmsk.dts中添加nand配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//(arch/arm/dts/am335x-evmsk.dts)&amp;elm &#123; status = \"okay\";&#125;;&amp;gpmc &#123; status = \"okay\"; pinctrl-names = \"default\"; pinctrl-0 = &lt;&amp;nandflash_pins_s0&gt;; ranges = &lt;0 0 0x08000000 0x1000000&gt;; /* CS0: 16MB for NAND */ nand@0,0 &#123; compatible = \"ti,omap2-nand\"; reg = &lt;0 0 4&gt;; /* CS0, offset 0, IO size 4 */ interrupt-parent = &lt;&amp;gpmc&gt;; interrupts = &lt;0 IRQ_TYPE_NONE&gt;, /* fifoevent */ &lt;1 IRQ_TYPE_NONE&gt;; /* termcount */ rb-gpios = &lt;&amp;gpmc 0 GPIO_ACTIVE_HIGH&gt;; /* gpmc_wait0 */ ti,nand-xfer-type = \"prefetch-dma\"; ti,nand-ecc-opt = \"bch8\"; ti,elm-id = &lt;&amp;elm&gt;; nand-bus-width = &lt;8&gt;; gpmc,device-width = &lt;1&gt;; gpmc,sync-clk-ps = &lt;0&gt;; gpmc,cs-on-ns = &lt;0&gt;; gpmc,cs-rd-off-ns = &lt;44&gt;; gpmc,cs-wr-off-ns = &lt;44&gt;; gpmc,adv-on-ns = &lt;6&gt;; gpmc,adv-rd-off-ns = &lt;34&gt;; gpmc,adv-wr-off-ns = &lt;44&gt;; gpmc,we-on-ns = &lt;0&gt;; gpmc,we-off-ns = &lt;40&gt;; gpmc,oe-on-ns = &lt;0&gt;; gpmc,oe-off-ns = &lt;54&gt;; gpmc,access-ns = &lt;64&gt;; gpmc,rd-cycle-ns = &lt;82&gt;; gpmc,wr-cycle-ns = &lt;82&gt;; gpmc,wait-on-read = \"true\"; gpmc,wait-on-write = \"true\"; gpmc,bus-turnaround-ns = &lt;0&gt;; gpmc,cycle2cycle-delay-ns = &lt;0&gt;; gpmc,clk-activation-ns = &lt;0&gt;; gpmc,wait-monitoring-ns = &lt;0&gt;; gpmc,wr-access-ns = &lt;40&gt;; gpmc,wr-data-mux-bus-ns = &lt;0&gt;; /* MTD partition table */ /* All SPL-* partitions are sized to minimal length * which can be independently programmable. For * NAND flash this is equal to size of erase-block */ #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; partition@0 &#123; label = \"NAND.SPL\"; reg = &lt;0x00000000 0x000020000&gt;; &#125;; partition@1 &#123; label = \"NAND.SPL.backup1\"; reg = &lt;0x00020000 0x00020000&gt;; &#125;; partition@2 &#123; label = \"NAND.SPL.backup2\"; reg = &lt;0x00040000 0x00020000&gt;; &#125;; partition@3 &#123; label = \"NAND.SPL.backup3\"; reg = &lt;0x00060000 0x00020000&gt;; &#125;; partition@4 &#123; label = \"NAND.u-boot-spl-os\"; reg = &lt;0x00080000 0x00040000&gt;; &#125;; partition@5 &#123; label = \"NAND.u-boot\"; reg = &lt;0x000C0000 0x00100000&gt;; &#125;; partition@6 &#123; label = \"NAND.u-boot-env\"; reg = &lt;0x001C0000 0x00020000&gt;; &#125;; partition@7 &#123; label = \"NAND.u-boot-env.backup1\"; reg = &lt;0x001E0000 0x00020000&gt;; &#125;; partition@8 &#123; label = \"NAND.kernel\"; reg = &lt;0x00200000 0x00800000&gt;; &#125;; partition@9 &#123; label = \"NAND.file-system\"; reg = &lt;0x00A00000 0x0F600000&gt;; &#125;; &#125;;&#125;; 1234567891011121314151617181920//(arch/arm/dts/am335x-evmsk.dts)nandflash_pins_s0: nandflash_pins_s0 &#123; pinctrl-single,pins = &lt; AM33XX_IOPAD(0x800, PIN_INPUT_PULLUP | MUX_MODE0) /* gpmc_ad0.gpmc_ad0 */ AM33XX_IOPAD(0x804, PIN_INPUT_PULLUP | MUX_MODE0) /* gpmc_ad1.gpmc_ad1 */ AM33XX_IOPAD(0x808, PIN_INPUT_PULLUP | MUX_MODE0) /* gpmc_ad2.gpmc_ad2 */ AM33XX_IOPAD(0x80c, PIN_INPUT_PULLUP | MUX_MODE0) /* gpmc_ad3.gpmc_ad3 */ AM33XX_IOPAD(0x810, PIN_INPUT_PULLUP | MUX_MODE0) /* gpmc_ad4.gpmc_ad4 */ AM33XX_IOPAD(0x814, PIN_INPUT_PULLUP | MUX_MODE0) /* gpmc_ad5.gpmc_ad5 */ AM33XX_IOPAD(0x818, PIN_INPUT_PULLUP | MUX_MODE0) /* gpmc_ad6.gpmc_ad6 */ AM33XX_IOPAD(0x81c, PIN_INPUT_PULLUP | MUX_MODE0) /* gpmc_ad7.gpmc_ad7 */ AM33XX_IOPAD(0x870, PIN_INPUT_PULLUP | MUX_MODE0) /* gpmc_wait0.gpmc_wait0 */ AM33XX_IOPAD(0x874, PIN_INPUT_PULLUP | MUX_MODE7) /* gpmc_wpn.gpio0_30 */ AM33XX_IOPAD(0x87c, PIN_OUTPUT | MUX_MODE0) /* gpmc_csn0.gpmc_csn0 */ AM33XX_IOPAD(0x890, PIN_OUTPUT | MUX_MODE0) /* gpmc_advn_ale.gpmc_advn_ale */ AM33XX_IOPAD(0x894, PIN_OUTPUT | MUX_MODE0) /* gpmc_oen_ren.gpmc_oen_ren */ AM33XX_IOPAD(0x898, PIN_OUTPUT | MUX_MODE0) /* gpmc_wen.gpmc_wen */ AM33XX_IOPAD(0x89c, PIN_OUTPUT | MUX_MODE0) /* gpmc_be0n_cle.gpmc_be0n_cle */ &gt;;&#125;; 使能nand的pinmux 12345678910//enable_board_pin_mux(board/ti/am335x/mux.c)else if (board_is_evm_sk()) &#123; /* Starter Kit EVM */ configure_module_pin_mux(nand_pin_mux); //添加NAND PINMUX配置 configure_module_pin_mux(i2c1_pin_mux); configure_module_pin_mux(gpio0_7_pin_mux); configure_module_pin_mux(rgmii1_pin_mux); configure_module_pin_mux(mmc0_pin_mux_sk_evm);&#125; MMC配置1234567891011121314151617181920mmc1_pins: pinmux_mmc1_pins &#123; pinctrl-single,pins = &lt; AM33XX_IOPAD(0x8f0, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc0_dat3.mmc0_dat3, INPUT_PULLUP, MODE0 */ AM33XX_IOPAD(0x8f4, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc0_dat2.mmc0_dat2, INPUT_PULLUP, MODE0 */ AM33XX_IOPAD(0x8f8, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc0_dat1.mmc0_dat1, INPUT_PULLUP, MODE0 */ AM33XX_IOPAD(0x8fc, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc0_dat0.mmc0_dat0, INPUT_PULLUP, MODE0 */ AM33XX_IOPAD(0x900, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc0_clk.mmc0_clk, INPUT_PULLUP, MODE0 */ AM33XX_IOPAD(0x904, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc0_cmd.mmc0_cmd, INPUT_PULLUP, MODE0 */ AM33XX_IOPAD(0x9a0, PIN_INPUT | MUX_MODE7) /* mcasp0_aclkr.gpio3_18 */ &gt;;&#125;;&amp;mmc1 &#123; status = \"okay\"; vmmc-supply = &lt;&amp;vmmc_reg&gt;; bus-width = &lt;4&gt;; pinctrl-names = \"default\"; pinctrl-0 = &lt;&amp;mmc1_pins&gt;; cd-gpios = &lt;&amp;gpio3 18 GPIO_ACTIVE_LOW&gt;;&#125;; ETH配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110cpsw_default: cpsw_default &#123; pinctrl-single,pins = &lt; /* Slave 1 */ AM33XX_IOPAD(0x914, PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* mii1_txen.rgmii1_tctl */ AM33XX_IOPAD(0x918, PIN_INPUT_PULLDOWN | MUX_MODE2) /* mii1_rxdv.rgmii1_rctl */ AM33XX_IOPAD(0x91c, PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* mii1_txd3.rgmii1_td3 */ AM33XX_IOPAD(0x920, PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* mii1_txd2.rgmii1_td2 */ AM33XX_IOPAD(0x924, PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* mii1_txd1.rgmii1_td1 */ AM33XX_IOPAD(0x928, PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* mii1_txd0.rgmii1_td0 */ AM33XX_IOPAD(0x92c, PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* mii1_txclk.rgmii1_tclk */ AM33XX_IOPAD(0x930, PIN_INPUT_PULLDOWN | MUX_MODE2) /* mii1_rxclk.rgmii1_rclk */ AM33XX_IOPAD(0x934, PIN_INPUT_PULLDOWN | MUX_MODE2) /* mii1_rxd3.rgmii1_rd3 */ AM33XX_IOPAD(0x938, PIN_INPUT_PULLDOWN | MUX_MODE2) /* mii1_rxd2.rgmii1_rd2 */ AM33XX_IOPAD(0x93c, PIN_INPUT_PULLDOWN | MUX_MODE2) /* mii1_rxd1.rgmii1_rd1 */ AM33XX_IOPAD(0x940, PIN_INPUT_PULLDOWN | MUX_MODE2) /* mii1_rxd0.rgmii1_rd0 */ /* Slave 2 */ AM33XX_IOPAD(0x840, PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* gpmc_a0.rgmii2_tctl */ AM33XX_IOPAD(0x844, PIN_INPUT_PULLDOWN | MUX_MODE2) /* gpmc_a1.rgmii2_rctl */ AM33XX_IOPAD(0x848, PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* gpmc_a2.rgmii2_td3 */ AM33XX_IOPAD(0x84c, PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* gpmc_a3.rgmii2_td2 */ AM33XX_IOPAD(0x850, PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* gpmc_a4.rgmii2_td1 */ AM33XX_IOPAD(0x854, PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* gpmc_a5.rgmii2_td0 */ AM33XX_IOPAD(0x858, PIN_OUTPUT_PULLDOWN | MUX_MODE2) /* gpmc_a6.rgmii2_tclk */ AM33XX_IOPAD(0x85c, PIN_INPUT_PULLDOWN | MUX_MODE2) /* gpmc_a7.rgmii2_rclk */ AM33XX_IOPAD(0x860, PIN_INPUT_PULLDOWN | MUX_MODE2) /* gpmc_a8.rgmii2_rd3 */ AM33XX_IOPAD(0x864, PIN_INPUT_PULLDOWN | MUX_MODE2) /* gpmc_a9.rgmii2_rd2 */ AM33XX_IOPAD(0x868, PIN_INPUT_PULLDOWN | MUX_MODE2) /* gpmc_a10.rgmii2_rd1 */ AM33XX_IOPAD(0x86c, PIN_INPUT_PULLDOWN | MUX_MODE2) /* gpmc_a11.rgmii2_rd0 */ &gt;;&#125;;cpsw_sleep: cpsw_sleep &#123; pinctrl-single,pins = &lt; /* Slave 1 reset value */ AM33XX_IOPAD(0x914, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x918, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x91c, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x920, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x924, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x928, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x92c, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x930, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x934, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x938, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x93c, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x940, PIN_INPUT_PULLDOWN | MUX_MODE7) /* Slave 2 reset value*/ AM33XX_IOPAD(0x840, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x844, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x848, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x84c, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x850, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x854, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x858, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x85c, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x860, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x864, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x868, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x86c, PIN_INPUT_PULLDOWN | MUX_MODE7) &gt;;&#125;;davinci_mdio_default: davinci_mdio_default &#123; pinctrl-single,pins = &lt; /* MDIO */ AM33XX_IOPAD(0x948, PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE0) /* mdio_data.mdio_data */ AM33XX_IOPAD(0x94c, PIN_OUTPUT_PULLUP | MUX_MODE0) /* mdio_clk.mdio_clk */ &gt;;&#125;;davinci_mdio_sleep: davinci_mdio_sleep &#123; pinctrl-single,pins = &lt; /* MDIO reset value */ AM33XX_IOPAD(0x948, PIN_INPUT_PULLDOWN | MUX_MODE7) AM33XX_IOPAD(0x94c, PIN_INPUT_PULLDOWN | MUX_MODE7) &gt;;&#125;;&amp;mac &#123; pinctrl-names = \"default\", \"sleep\"; pinctrl-0 = &lt;&amp;cpsw_default&gt;; pinctrl-1 = &lt;&amp;cpsw_sleep&gt;; dual_emac = &lt;1&gt;; status = \"okay\";&#125;;&amp;davinci_mdio &#123; pinctrl-names = \"default\", \"sleep\"; pinctrl-0 = &lt;&amp;davinci_mdio_default&gt;; pinctrl-1 = &lt;&amp;davinci_mdio_sleep&gt;; status = \"okay\";&#125;;&amp;cpsw_emac0 &#123; phy_id = &lt;&amp;davinci_mdio&gt;, &lt;4&gt;; phy-mode = \"rgmii-txid\"; dual_emac_res_vlan = &lt;1&gt;;&#125;;&amp;cpsw_emac1 &#123; phy_id = &lt;&amp;davinci_mdio&gt;, &lt;6&gt;; phy-mode = \"rgmii-txid\"; dual_emac_res_vlan = &lt;2&gt;;&#125;; USB配置配置usb0和usb1工作在host模式 1234567891011121314151617&amp;usb &#123; status = \"okay\";&#125;;&amp;usb_ctrl_mod &#123; status = \"okay\";&#125;;&amp;usb0 &#123; status = \"okay\"; dr_mode = \"host\";&#125;;&amp;usb1 &#123; status = \"okay\"; dr_mode = \"host\";&#125; NAND启动环境变量问题15.nand启动环境变量问题：## Error: “bootcmd_nand0” not defined启动时会寻找环境变量bootcmd_nand0，但uboot生成的环境变量为bootcmd_nand 修改 BOOTENV_DEV_NAND 12345678(include/configs/am335x_evm.h)//#define BOOTENV_DEV_NAND(devtypeu, devtypel, instance) \\// \"bootcmd_\" #devtypel \"=\" \\// \"run nandboot\\0\"#define BOOTENV_DEV_NAND(devtypeu, devtypel, instance) \\ \"bootcmd_\" #devtypel #instance \"=\" \\ \"run nandboot\\0\" 支持U盘烧写Nand从usb fat设备中加载文件 12345678910111213141516171819202122232425262728293031323334353637383940414243//(cmd/fat.c)int usb_fat_fsload (char*filename, char* addr, int *ReadSize)&#123; char *usbName = \"usb\"; long size; //unsigned long offset; char *offset; struct blk_desc *dev_desc = NULL; int dev = 0; int part = 1; char *ep; dev = (int)simple_strtoul (\"0:4\", &amp;ep, 16); dev_desc = blk_get_dev(usbName, dev); if (dev_desc == NULL) &#123; puts (\"\\n** Invalid boot device **\\n\"); return 1; &#125; if (*ep) &#123; if (*ep != ':') &#123; puts (\"\\n** Invalid boot device, use `dev[:part]' **\\n\"); return 1; &#125; part = (int)simple_strtoul(++ep, NULL, 16); &#125; if (fat_register_device(dev_desc, part)!=0) &#123; printf (\"\\n** Unable to use %s %d:%d for fatload **\\n\", usbName, dev, part); return 1; &#125; offset = addr; size = file_fat_read (filename, (unsigned char *) offset, 0); if(size == -1) &#123; printf(\"\\n** Unable to read \\\"%s\\\" from %s %d:%d **\\n\", filename, usbName, dev, part); return 1; &#125; printf (\"\\n%ld bytes read\\n\", size); if(ReadSize) *ReadSize = size; return 0;&#125; 查找usb设备数量 1234567891011121314151617181920212223242526272829303132//(common/usb_storage.c)int usb_stor_count(void)&#123; int count = 0;#ifdef CONFIG_BLK struct udevice *dev; for (blk_first_device(IF_TYPE_USB, &amp;dev); dev; blk_next_device(&amp;dev)) &#123; //struct blk_desc *desc = dev_get_uclass_platdata(dev); //printf(\" Device %d: \", desc-&gt;devnum); //dev_print(desc); count++; &#125;#else int i; if (usb_max_devs &gt; 0) &#123; for (i = 0; i &lt; usb_max_devs; i++) &#123; //printf(\" Device %d: \", i); //dev_print(&amp;usb_dev_desc[i]); count++; &#125; //return 0; &#125;#endif return count;&#125; 主要的升级程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305(common/autoboot.c)/*+------------+--&gt;0x00000000-&gt; NAND.SPL start (SPL copy on 1st block)| || |--&gt;0x0001FFFF-&gt; NAND.SPL end | |--&gt;0x00020000-&gt; NAND.SPL.backup1 start (SPL copy on 2nd block)| || |--&gt;0x0003FFFF-&gt; NAND.SPL.backup1 end | |--&gt;0x00040000-&gt; NAND.SPL.backup2 start (SPL copy on 3rd block)| || |--&gt;0x0005FFFF-&gt; NAND.SPL.backup2 end | |--&gt;0x00060000-&gt; NAND.SPL.backup3 start (SPL copy on 4th block)| || |--&gt;0x0007FFFF-&gt; NAND.SPL.backup3 end| |--&gt;0x00080000-&gt; NAND.u-boot-spl-os start| || |--&gt;0x000BFFFF-&gt; NAND.u-boot-spl-os end| |--&gt;0x000C0000-&gt; NAND.u-boot start| || |--&gt;0x001BFFFF-&gt; NAND.u-boot end| |--&gt;0x001C0000-&gt; NAND.u-boot-env start| | | |--&gt;0x001DFFFF-&gt; NAND.u-boot-env end | |--&gt;0x001E0000-&gt; NAND.u-boot-env.backup1 start| || |--&gt;0x001FFFFF-&gt; NAND.u-boot-env.backup1 end| |--&gt;0x00200000-&gt; NAND.kernel start| || || || || |--&gt;0x009FFFFF-&gt; NAND.kernel end| |--&gt;0x00A00000-&gt; NAND.file-system start| || || || || || || || || || || || |+------------+--&gt;0x10000000-&gt; NAND end (Free end)device nand0 &lt;nand.0&gt;, # parts = 10 #: name size offset mask_flags 0: NAND.SPL 0x00020000 0x00000000 0 1: NAND.SPL.backup1 0x00020000 0x00020000 0 2: NAND.SPL.backup2 0x00020000 0x00040000 0 3: NAND.SPL.backup3 0x00020000 0x00060000 0 4: NAND.u-boot-spl-os 0x00040000 0x00080000 0 5: NAND.u-boot 0x00100000 0x000c0000 0 6: NAND.u-boot-env 0x00020000 0x001c0000 0 7: NAND.u-boot-env.backup10x00020000 0x001e0000 0 8: NAND.kernel 0x00800000 0x00200000 0 9: NAND.file-system 0x0f600000 0x00a00000 0*/#define PARTITION_NUM (10)#define OFFSET_SPL 0x00000000#define OFFSET_SPL_BACKUP1 0x00020000#define OFFSET_SPL_BACKUP2 0x00040000#define OFFSET_SPL_BACKUP3 0x00060000#define OFFSET_UBOOT_SPL_OS 0x00080000#define OFFSET_UBOOT 0x000c0000#define OFFSET_UBOOT_ENV 0x001c0000#define OFFSET_UBOOT_ENV_BACKUP1 0x001e0000#define OFFSET_KERNEL 0x00200000#define OFFSET_FILE_SYSTEM 0x00a00000#define SIZE_SPL 0x00020000#define SIZE_SPL_BACKUP1 0x00020000#define SIZE_SPL_BACKUP2 0x00020000#define SIZE_SPL_BACKUP3 0x00020000#define SIZE_UBOOT_SPL_OS 0x00040000#define SIZE_UBOOT 0x00100000#define SIZE_UBOOT_ENV 0x00020000#define SIZE_UBOOT_ENV_BACKUP1 0x00020000#define SIZE_KERNEL 0x00800000#define SIZE_FILE_SYSTEM 0x0f600000#define IMAGE_SPL \"images/MLO\"#define IMAGE_SPL_BACKUP1 \"images/MLO\"#define IMAGE_SPL_BACKUP2 \"images/MLO\"#define IMAGE_SPL_BACKUP3 \"images/MLO\"#define IMAGE_UBOOT_SPL_OS \"images/am335x-evmsk.dtb\"#define IMAGE_UBOOT \"images/u-boot.img\"#define IMAGE_UBOOT_ENV \"images/uboot.env\"#define IMAGE_UBOOT_ENV_BACKUP1 \"images/uboot.env\"#define IMAGE_KERNEL \"images/zImage\"#define IMAGE_FILE_SYSTEM \"images/ubi.img\"#define PARTITION_SPL \"NAND.SPL\"#define PARTITION_SPL_BACKUP1 \"NAND.SPL.backup1\"#define PARTITION_SPL_BACKUP2 \"NAND.SPL.backup2\"#define PARTITION_SPL_BACKUP3 \"NAND.SPL.backup3\"#define PARTITION_UBOOT_SPL_OS \"NAND.u-boot-spl-os\"#define PARTITION_UBOOT \"NAND.u-boot\"#define PARTITION_UBOOT_ENV \"NAND.u-boot-env\"#define PARTITION_UBOOT_ENV_BACKUP1 \"NAND.u-boot-env.backup1\"#define PARTITION_KERNEL \"NAND.kernel\"#define PARTITION_FILE_SYSTEM \"NAND.file-system\"enum&#123; IMAGE_TYPE_RAW, IMAGE_TYPE_YAFFS2, IMAGE_TYPE_JFFS2, IMAGE_TYPE_UBIFS, IMAGE_TYPE_CRAMFS,&#125;;static int usb_upload_nand()&#123; printf(\"Scanning USB...\"); int ret = parse_string_outer(\"usb start\", FLAG_PARSE_SEMICOLON | FLAG_EXIT_FROM_LOOP); if(ret != 0) &#123; printf(\"usb start failed\\n\"); return 0; &#125; // get storage counter if(usb_stor_count() == 0) &#123; printf(\"No USB Found. Booting...\\n\"); return 0; &#125; printf(\"USB Found.\\n\"); udelay(2 * 1000 * 1000); printf(\"Prepare to Updating...\\n\"); udelay(2 * 1000 * 1000); char *partition_name[PARTITION_NUM] = &#123; PARTITION_SPL, \\ PARTITION_SPL_BACKUP1, \\ PARTITION_SPL_BACKUP2, \\ PARTITION_SPL_BACKUP3, \\ PARTITION_UBOOT_SPL_OS, \\ PARTITION_UBOOT, \\ PARTITION_UBOOT_ENV, \\ PARTITION_UBOOT_ENV_BACKUP1, \\ PARTITION_KERNEL, \\ PARTITION_FILE_SYSTEM&#125;; char *image_name[PARTITION_NUM] = &#123; IMAGE_SPL, \\ IMAGE_SPL_BACKUP1, \\ IMAGE_SPL_BACKUP2, \\ IMAGE_SPL_BACKUP3, \\ IMAGE_UBOOT_SPL_OS, \\ IMAGE_UBOOT, \\ IMAGE_UBOOT_ENV, \\ IMAGE_UBOOT_ENV_BACKUP1, \\ IMAGE_KERNEL, \\ IMAGE_FILE_SYSTEM&#125;; int partition_addr[PARTITION_NUM] = &#123; OFFSET_SPL, \\ OFFSET_SPL_BACKUP1, \\ OFFSET_SPL_BACKUP2, \\ OFFSET_SPL_BACKUP3, \\ OFFSET_UBOOT_SPL_OS, \\ OFFSET_UBOOT, \\ OFFSET_UBOOT_ENV, \\ OFFSET_UBOOT_ENV_BACKUP1, \\ OFFSET_KERNEL, \\ OFFSET_FILE_SYSTEM&#125;; int load_addr[PARTITION_NUM] = &#123; 0x82000000 + OFFSET_SPL, \\ 0x82000000 + OFFSET_SPL_BACKUP1, \\ 0x82000000 + OFFSET_SPL_BACKUP2, \\ 0x82000000 + OFFSET_SPL_BACKUP3, \\ 0x82000000 + OFFSET_UBOOT_SPL_OS, \\ 0x82000000 + OFFSET_UBOOT, \\ 0x82000000 + OFFSET_UBOOT_ENV, \\ 0x82000000 + OFFSET_UBOOT_ENV_BACKUP1, \\ 0x82000000 + OFFSET_KERNEL, \\ 0x82000000 + OFFSET_FILE_SYSTEM&#125;; int partition_size[PARTITION_NUM] = &#123; SIZE_SPL, \\ SIZE_SPL_BACKUP1, \\ SIZE_SPL_BACKUP2, \\ SIZE_SPL_BACKUP3, \\ SIZE_UBOOT_SPL_OS, \\ SIZE_UBOOT, \\ SIZE_UBOOT_ENV, \\ SIZE_UBOOT_ENV_BACKUP1, \\ SIZE_KERNEL, \\ SIZE_FILE_SYSTEM&#125;; int image_size[PARTITION_NUM] = &#123; SIZE_SPL, \\ SIZE_SPL_BACKUP1, \\ SIZE_SPL_BACKUP2, \\ SIZE_SPL_BACKUP3, \\ SIZE_UBOOT_SPL_OS, \\ SIZE_UBOOT, \\ SIZE_UBOOT_ENV, \\ SIZE_UBOOT_ENV_BACKUP1, \\ SIZE_KERNEL, \\ SIZE_FILE_SYSTEM&#125;; int image_type[PARTITION_NUM] = &#123; IMAGE_TYPE_RAW, \\ IMAGE_TYPE_RAW, \\ IMAGE_TYPE_RAW, \\ IMAGE_TYPE_RAW, \\ IMAGE_TYPE_RAW, \\ IMAGE_TYPE_RAW, \\ IMAGE_TYPE_RAW, \\ IMAGE_TYPE_RAW, \\ IMAGE_TYPE_RAW, \\ IMAGE_TYPE_RAW&#125;; char buffer[128]; buffer[127] = '\\0'; int i = 0; for(i = 0; i &lt; PARTITION_NUM; i++) &#123; printf(\"Checking %s \\n\", image_name[i]); char step[32]; sprintf(step, \"[%d/%d]\", i+1, PARTITION_NUM); sprintf(buffer, \"Step:%s Checking %s...\\n\", step, image_name[i]); printf(buffer); ret = usb_fat_fsload(image_name[i], load_addr[i], &amp;image_size[i]); if(ret == 0 &amp;&amp; image_size[i] &gt; 0) &#123; &#125; else &#123; sprintf(\"%s%s is lost.\", step, partition_name[i]); printf(buffer); printf(\"load image failed!!!\\n\"); return 0; &#125; sprintf(buffer, \"%s Success.\", step); udelay(2 * 1000 * 1000); &#125; printf(\"[DO NOT POWER OFF]\\n\"); // Load success !!! // Start write nand char cmd[255]; char *command = NULL; for(i = 0; i &lt; PARTITION_NUM; i++) &#123; switch(image_type[i]) &#123; case IMAGE_TYPE_RAW: command = \"nand write \"; break; case IMAGE_TYPE_YAFFS2: command = \"nand write.yaffs2 \"; break; case IMAGE_TYPE_JFFS2: command = \" \"; break; case IMAGE_TYPE_UBIFS: command = \"ubi write \"; break; default: break; &#125; sprintf(buffer, \"[%d/%d]Updating %s...\\n\", i+1, PARTITION_NUM, partition_name[i]); printf(buffer); sprintf(cmd, \"nand erase %x %x ; %s %x %x %x ;\", partition_addr[i], partition_size[i], command, load_addr[i], partition_addr[i], image_size[i]); printf(\"cmd : %s \\n\", cmd); ret = parse_string_outer(cmd, FLAG_PARSE_SEMICOLON | FLAG_EXIT_FROM_LOOP); if(ret != 0) &#123; //write error sprintf(ivp2_check_err_msg, \"[%d/%d]Partition %s corrupt\", i, PARTITION_NUM, partition_name[i]); return 0; &#125; sprintf(buffer, \"[%d/%d] Success.\\n\", i+1, PARTITION_NUM); printf(buffer); udelay(2 * 1000 * 1000 ); &#125; printf(\"[SUCCESS]\\n\"); return 1;&#125; 倒数之后，检测USB，执行升级程序 1234567891011121314151617181920212223242526272829303132333435void autoboot_command(const char *s)&#123; debug(\"### main_loop: bootcmd=\\\"%s\\\"\\n\", s ? s : \"&lt;UNDEFINED&gt;\"); if (stored_bootdelay != -1 &amp;&amp; s &amp;&amp; !abortboot(stored_bootdelay)) &#123; if(usb_upload_nand() != 1) &#123; printf(\"usb_upload_nand failed!\\n\"); &#125; else &#123; printf(\"usb_upload_nand success!\\n\"); udelay(2 * 1000 * 1000); printf(\"enter kernel!\\n\"); &#125; #if defined(CONFIG_AUTOBOOT_KEYED) &amp;&amp; !defined(CONFIG_AUTOBOOT_KEYED_CTRLC) int prev = disable_ctrlc(1); /* disable Control C checking */#endif run_command_list(s, -1, 0);#if defined(CONFIG_AUTOBOOT_KEYED) &amp;&amp; !defined(CONFIG_AUTOBOOT_KEYED_CTRLC) disable_ctrlc(prev); /* restore Control C checking */#endif &#125;#ifdef CONFIG_MENUKEY if (menukey == CONFIG_MENUKEY) &#123; s = getenv(\"menucmd\"); if (s) run_command_list(s, -1, 0); &#125;#endif /* CONFIG_MENUKEY */ Nand Flash分区 |····························|–&gt;0x00000000-&gt; NAND.SPL start (SPL copy on 1st block)|····························||····························|–&gt;0x0001FFFF-&gt; NAND.SPL end|····························|–&gt;0x00020000-&gt; NAND.SPL.backup1 start (SPL copy on 2nd block)|····························||····························|–&gt;0x0003FFFF-&gt; NAND.SPL.backup1 end|····························|–&gt;0x00040000-&gt; NAND.SPL.backup2 start (SPL copy on 3rd block)|····························||····························|–&gt;0x0005FFFF-&gt; NAND.SPL.backup2 end|····························|–&gt;0x00060000-&gt; NAND.SPL.backup3 start (SPL copy on 4th block)|····························||····························|–&gt;0x0007FFFF-&gt; NAND.SPL.backup3 end|····························|–&gt;0x00080000-&gt; NAND.u-boot-spl-os start|····························||····························|–&gt;0x000BFFFF-&gt; NAND.u-boot-spl-os end|····························|–&gt;0x000C0000-&gt; NAND.u-boot start|····························||····························|–&gt;0x001BFFFF-&gt; NAND.u-boot end|····························|–&gt;0x001C0000-&gt; NAND.u-boot-env start|····························||····························|–&gt;0x001DFFFF-&gt; NAND.u-boot-env end|····························|–&gt;0x001E0000-&gt; NAND.u-boot-env.backup1 start|····························||····························|–&gt;0x001FFFFF-&gt; NAND.u-boot-env.backup1 end|····························|–&gt;0x00200000-&gt; NAND.kernel start|····························||····························||····························||····························||····························|–&gt;0x009FFFFF-&gt; NAND.kernel end|····························|–&gt;0x00A00000-&gt; NAND.file-system start|····························||····························||····························||····························||····························||····························||····························||····························||····························||····························||····························||····························||····························|–&gt;0x10000000-&gt; NAND end (Free end) Name Size offset mask_flags 0: NAND.SPL 0x00020000 0x00000000 0 1: NAND.SPL.backup1 0x00020000 0x00020000 0 2: NAND.SPL.backup2 0x00020000 0x00040000 0 3: NAND.SPL.backup3 0x00020000 0x00060000 0 4: NAND.u-boot-spl-os 0x00040000 0x00080000 0 5: NAND.u-boot 0x00100000 0x000c0000 0 6: NAND.u-boot-env 0x00020000 0x001c0000 0 7: NAND.u-boot-env.backup1 0x00020000 0x001e0000 0 8: NAND.kernel 0x00800000 0x00200000 0 9: NAND.file-system 0x0f600000 0x00a00000 0 Kernel移植添加SCSI SG驱动 Device Drivers —&gt;&nbsp;&nbsp;&nbsp;&nbsp;SCSI device support —&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SCSI generic support [Symbol: CHR_DEV_SG] 添加CP210x USB Serial Converter驱动 Device Drivers —&gt;&nbsp;&nbsp;&nbsp;&nbsp;USB support —&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;USB Serial Converter support —&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;USB CP210x family of UART Bridge Controllers dts配置Kernel dts路径 arch/arm/boot/dts/am335x-evmsk.dts配置方法与u-boot类似 Rootfs移植进入内核目录执行以下命令安装模块，INSTALL_MOD_PATH为文件系统目录，内核配置有更新时安装。 make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modulesmake ARCH=arm INSTALL_MOD_PATH=/media/huiwei/rootfs modules_install 将ti-processor-sdk-linux-am335x-evm-04.03.00.05/filesystem/lib/firmware/目录中的文件拷贝到文件系统/lib/firmware 进入文件系统的上级目录，执行以下命令 mkfs.ubifs -F -q -r filesystem -m 2048 -e 126976 -c 2047 -o ubifs.imgubinize -o ubi.img -m 2048 -p 128KiB ubinize.cfg 123456789//ubinize.cfg文件内容[ubifs]mode=ubiimage=ubifs.imgvol_id=0vol_size=200MiBvol_type=dynamicvol_name=rootfsvol_flags=autoresize 注意： mkfs.ubifs 和 ubinize 最好使用SDK中的二进制文件，目录为ti-processor-sdk-linux-am335x-evm-04.03.00.05/linux-devkit/sysroots/x86_64-arago-linux/usr/bin/ ubifs.img为ubi格式镜像，在Nand烧写时使用ubi write命令烧写 ubi.img为处理之后的raw格式镜像，在Nand烧写时使用nand write命令烧写 filesystem 为rootfs目录的路径 Nand Flash烧写MMC烧写Nand Flashmmc rescannand erase 0x0 0xA00000fatload mmc 0 0x82000000 MLOcp.b 0x82000000 0x82020000 20000cp.b 0x82000000 0x82040000 20000cp.b 0x82000000 0x82060000 20000fatload mmc 0 0x82080000 am335x-evmsk.dtbfatload mmc 0 0x820C0000 u-boot.imgfatload mmc 0 0x82200000 zImagenand write 0x82000000 0x0 0xA00000 fatload mmc 0 0x82000000 ubi.imgnand erase 0xA00000 0xF600000nand write 0x82000000 0xA00000 0x1860000 USB烧写Nand Flashusb startnand erase 0x0 0xA00000fatload usb 0:4 0x82000000 MLOcp.b 0x82000000 0x82020000 20000cp.b 0x82000000 0x82040000 20000cp.b 0x82000000 0x82060000 20000fatload usb 0:4 0x82080000 am335x-evmsk.dtbfatload usb 0:4 0x820C0000 u-boot.imgfatload usb 0:4 0x82200000 zImagenand write 0x82000000 0x0 0xA00000 fatload usb 0:4 0x82000000 ubi.imgnand erase 0xA00000 0xF600000nand write 0x82000000 0xA00000 0x1860000 相关资料 Processor SDK Linux 04_03_00_05 Foundational Components U-Boot AM335x U-Boot User’s GuideARM MPU AM335X Industrial Automation EVM Base BoardAM335x and AMIC110 Sitara™ Processors Technical Reference Manual (Rev. P)AM335x DataSheetAM335x 硬件接口内存映射地址查询","categories":[{"name":"AM335X","slug":"AM335X","permalink":"http://yoursite.com/categories/AM335X/"}],"tags":[{"name":"AM335X","slug":"AM335X","permalink":"http://yoursite.com/tags/AM335X/"}]},{"title":"常用网站","slug":"常用网站","date":"2018-11-06T17:14:30.000Z","updated":"2019-09-17T10:05:35.698Z","comments":true,"path":"2018/11/07/常用网站/","link":"","permalink":"http://yoursite.com/2018/11/07/常用网站/","excerpt":"","text":"Linux Source Code: https://elixir.bootlin.com/linux/latest/source","categories":[],"tags":[]}]}